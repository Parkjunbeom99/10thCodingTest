
# 재귀 함수 
정의 단계에서 자기 자신을 참조하는 것 
매개변수가 달라질 뿐 함수는 같다 
큰 문제를 부분문제로 만들때 사용
// f(N)  ->
       f(N-1)
            f(N-2)
                f(N-3)
                    f(N-4)
                        f(N-5)
                        
                       
주의사항 
1. 종료조건이 있어야한다. 
2. 종료조건에 도달할 수 있도록 매개변수를 변경해야한다. 
3. 종료조건에 도달하지 못하면 무한루프에 빠진다. 
4. 종료조건에 도달하지 못하면 스택오버플로우가 발생한다. 
5. 반복문으로 될 거 같으면 반복문으로 하자  -> 코스트가 더 많이 든다 

점화식을 만들어서 감을 잡는게 좋다  
점화식은 “다음 값을 이전 값들로부터 계산하는 규칙”이다.
즉, 수열의 생성 규칙을 나타내는 수학식.


# 순열  -> NextPermutation()

순서와 상관 0 뽑는다면 >> 순열


123 만약 두개 뽑는다면 

순열  1 2 , 1 3 , 2 1 , 2 3 , 3 1 , 3 2

 
 C++ 에서 next_permutation() 순열 사용을 사용하면 된다.   -> 오름차순으로 정렬을 하고 사용해야한다  사용전 Sort함수 사용 필수 !!
 안에 매개변수로 from, to 이다   
 
 수학적 공식 알면 좋으니 기억하자 
 nPr = n! / (n-r)!
 
 
 순서를 재배치나 순서 관련 문항이 나오면 순열이라고 생각하자 
 순서와 상관 X 뽑는다면 >> 조합
 
 # 조합  
 그저 몇명을 뽑을까 ?

123 만약 두개 뽑는다면 
조합  1 2 , 1 3 , 2 3
  
 수학적 공식
 nCr = n! / r!(n-r)!
 
 //Split  -> 직접 구현이 필요하다 
 
 특정 문자를 기반으로 분류해서 넣는것 
 이거는 그냥 Chap001.cpp에 있는거 그대로 가져다 쓰면 된다.
 
 
 # Unique , Map사용    중복된 요소를 제거해서 뽑아내는 것 
    Unique -> 범위안의 요소 중에 앞에서부터 비교하여서 중복된 요소를 뒤로 보내버린다. 
    그래서 사용 전에 정렬이 필요하다  ->O(n)의 시간 복잡도 
    그리고 함수를 실행하면 이터레이터가 리턴된다 
    중복되지 않은 요소의 끝의 다음을 가리키는 이터레이터가 리턴된다. 
    그래서 해당 IT -V.begin()을 하면 중복되지 않은 요소의 개수를 알 수 있다. 
    
    sort(v.begin(), v.end());
    V.erase(unique(v.begin(), v.end()), v.end()); // 중복된 요소를 제거한다. 
    


