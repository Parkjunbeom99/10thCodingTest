
# 2주차 

그래프 이론 

정점과 간선 

정점을 노드이고 그래프 형성 기본단위

간선이 정점을 잊는 선 -> 여기서 가중치가 존재할 수 있다. 


트리
트리는 자식노드와 부모노드로 이루어진 계층적인 구조를 가지며 무방향 그래프의 일종이자 사이클이 없는 자료구조를 의미

특징 
v-1 = E  간선의 수 는 노드의 수 -1 이다 
 
 깊이: 트리의 깊이는 루트 노드부터 리프 노드까지의 거리 중 가장 짧은 거리를 의미
 높이: 트리의 높이는 루트 노드부터 리프 노드까지의 거리 중 가장 긴 거리를 의미
 서브트리: 트리 내의 하위 집합을 서브트리
 
 
 이진트리(BT, Binary Tree)
 노드의 자식노드 수가 2개 이하로 구성되어있는 트리
 
 정이진 트리(full binary tree): 자식 노드가 0 또는 2개인 이진 트리
 완전 이진 트리(complete binary tree): 왼쪽에서부터 채워져 있는 이진 트리를 의미합니다
 변질 이진 트리(degenerate binary tree): 리프노드 제외, 자식 노드가 하나밖에 없는 이진 트리
 포화 이진 트리(perfect binary tree): 모든 노드가 꽉 차 있는 이진 트리
 균형 이진 트리(balanced binary tree): 균형 이진 트리는 트리의 모든 노드에 대해, 그 노드의 왼쪽 하위 트리와 오른쪽 하위 트리의 높이 차이가 1 이하인 이진 트리 -> AVL, Red-Black Tree
 
 이진탐색트리(BST, Binary Search Tree)
 이진트리의 일종으로 노드의 오른쪽 하위 트리에는 "노드의 값보다 큰 값"이 있는 노드만 포함되고 왼쪽 하위트리에는 "노드의 값보다 작은값"이 들어있는 트리
 
 그래프 구현과 탐색 1. 인접행렬
 이중 배열로 해서 하면 된다 a[i][j] = 1;  여기서 i j는 각 노드이고  i-> j 로 갈 수 있다면 1넣고 아니면 0이다 
 
 
 
 그래프 구현과 탐색 2. 인접리스트
 vector<int> adj[V];
 adj[0].push_back(1); 
 adj[0].push_back(2);
 
 
 시간복잡도 : 간선 한개 찾기
 - 인접행렬 : O(1)
 - 인접리스트 : O(V)
 
 시간복잡도 : 모든 간선찾기
 - 인접행렬 : O(V^2)
 - 인접리스트 : O(V + E)
 
 그래서 사용 여부는 그래프가 조밀하게 구현되어 있습니다 인접 행렬 
 그래프가 희소하다면 인접리스트
 
 ->나는 그래서 보통 인접 리스트인 vector<vector<int>>로 구현을 한다.하지만 지정된 크기의 Map이라는게 존재하면 위와 같이 Array로 미리 크기를 할당해 놓는게 좋다.
 
 그래프 구현과 탐색 3. 맵과 방향벡터
 ex->
 const int dy[] = {-1, 0, 1, 0}; 
 const int dx[] = {0, 1, 0, -1};
  int main()
  {
    int y = 0, x = 0;
    for(int i = 0; i < 4; i++){ 
        int ny = y + dy[i];
        int nx = x + dx[i];
        cout << ny << " : " << nx << '\n';
         }
     return 0;
  } /*
      
  연결된 컴포넌트(connected component)
     연결된 컴포넌트(connected component)는 연결된 하위그래프를 말하며 연결된 하나의 덩어리라고 생각하자 
     
  깊이우선탐색 (DFS, Depth-First Search)
  그래프를 탐색할 때 쓰는 알고리즘이며 어떤 노드부터 시작해 인접한 노드들을 재귀적으로 
  방문하며 방문한 정점은 다시 방문하지 않으며
  각 분기마다 가능한 가장 멀리 있는 노드까지 
  탐색하는 알고리즘
    
   요약하자면 그냥 그래프에서 리프노드에 닿을때까지 탐색을하고 다시 올라가는 방식 
     
     나는 보통
     void DFS(int here){ 
     visited[here] = 1;
      for(int there : adj[here])
      { if(visited[there]) continue;
       DFS(there);
      }
     }
     이 방식으로 구현 한다 
      
      
   너비 우선 탐색(BFS, Breadth-First Search)
     그래프를 탐색하는 알고리즘이며 어떤 정점에서 시작해 다음 깊이의 정점으로 이동하기전
     현재 깊이의 모든 정점을 탐색하며 방문한 정점은 다시 방문하지 않는 알고리즘.
     
    요약 BFS로 탐색을 한다는 것은  레이어별, 레벨별로 탐색한다
    
    수도 코드 
    BFS(G, u)
     u.visited = true // 방문 체크 
     q.push(u); // 큐에 넣고 
      while(q.size())// Q가 비워져 있을때 까지 탐색 
        u = q.front() // 가장 앞에껄 가져오고 빼낸다   
          q.pop() 
          for each v ∈ G.Adj[u]  // 
          if v.visited == false 
               v.visited = true q.push(v) 그리고 인접한 리스트가 있다면 그 것을 Q.에 넣는다 
       
       
   보통 BFS는 최단거리 배열을 구할 때 사용한다 
   최단 거리 배열을 구할때는 visited를 bool이 아닌 int 로 해서        
   v.visited = u.visited + 1  현재 노드의 거리 +1 을 해 다음 노드에 넣어주면 된다  꼭 1이 아니라 가중치를 제공해주면 해당 가중치를 곱하자 
   
   
   시작지점이 다수" 라면 처음 큐에 푸시하는 지점도 다수가 되어야 하며 해당 지점들의 visited를 모두 1로 만들면서 시작해야 한다
   ex -> 123 동시 시작이면 q.push(1), q.push(2), q.push(3) 그리고 visited[1] = visited[2] = visited[3] = 1로 해야한다.
   
   그러나 BFS는 무조건 그래프 내에 가중치가 같아야한다 이건 필수로 알아야한다 
   
   bfs와 dfs 차이 
   DFS -> stack 
   메모리를 덜 씀. 절단점 등 구할 수 있음. 코드가 좀 더 짧으며 완전탐색의 경우에 많이 씀.
   BFS -> queue
   메모리를 더 씀. 가중치가 같은 그래프내에서 최단거리를 구할 수 있음. 코드가 더 김
   
   
   트리순회
   트리 순회(Tree traversal)는 트리 구조에서 각각의 노드를 정확히 한 번만, 체계적인 방법으로 방문하는 과정
   
   전위순회(Preorder Traversal) : 루트 -> 왼쪽 -> 오른쪽  ->DFS
   중위순회(Inorder Traversal) : 왼쪽 -> 루트 -> 오른쪽  
   후위순회(Postorder Traversal) : 왼쪽 -> 오른쪽 -> 루트 
   레벨 순회 : 레벨별로 순회  -> BFS 
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   