

시간복잡도

시간복잡도란 입력크기에 대해 어떠한 알고리즘이 실행되는데 걸리는 시간이며 주요로직의 반복횟수를 중점으로 측정

EX ->
for(int i = 0; i < 10; i++){
    for(int j =0; j < n; j++){
        for(int k = 0; k < n; k++){
         if(true) cout << k << '\n';
          }
        } 
    }
     for(int i = 0; i < n; i++){
      if(true) cout << i << '\n';
       }
      해당 시간 복잡도는 O(n^2)이다.
      빅오 표기법(Big - O notation) 이란 복잡도에 가장 영향을 많이 끼치는 항의 상수인자를 빼고 나머지 항을 없애서 복잡도를 나타내는 표기법
      
      n! > 2 ^ n > n ^2 > nlogn > n > logn > 1 순
      
      메인로직은 해당 함수에서 시간복잡도가 어느정도 큰 주요 로직이라고 보면 된다 
      
      문제마다 다르지만 100억이상 -> 절대 안됨 / 10억이상 -> 거의 안됨 / 1억 -> 어느정도는 됨 이렇게 생각하자
      
      
      자료구조의 시간복잡도 
      
      배열(Array)
      - 참조 : O(1)
      - 탐색 : O(n)
      연결리스트(doubly linked list)
      - 참조 : O(n)
      - 탐색 : O(n)
      - 삽입 / 삭제 : O(1)
      
     근데 코테에서는 그냥 Vector가 짱인거 같다 아무리 생각해도 아니면 Map이나 Set ?? 
     
     공간 시간 복잡도는 크게 생각을 안할꺼여서  그냥 개념만 알고 넘어가겠다 
     공간복잡도는 "입력크기에 대해 어떠한 알고리즘이 실행되는데 필요한 메모리 공간의 양 "".
     
     
     누적합 (Prifix sum)
     소들의 누적된 합의 의미로 어떠한 배열을 기반으로 앞에서 부터 요소들의 누적된 합을 저장해 새로이 배열을 만들어서 이를 활용하는 것
     
     문제를 풀 때 "구간"에 대한 많은 "쿼리"가 나올 때 생각해야 될 것은 트리 또는 누적합
     
     
     우리는 문제를 풀 때 다음과 같은 과정을 통해 문제를 풀어야 한다 
     문제해석 -> 손코딩 -> 코드를 작성 O -> 반례체크
     
  1. 단순구현이라면 구현하고 -> 문제의 최대, 최소 범위를 파악
  2. 최대범위 기반, 시간복잡도상 -> 무식하게 풀 수 있다면 무식하게 모든 경우의 수를 생각하면서 풀고 -> 이 때 구현할 부분들은 구현하자
  3. 그게 아니라면 다른 알고리즘을 생각하자.
  4. 제출하기전, 반례를 항상 생각하자. 
     
     
     
     
     