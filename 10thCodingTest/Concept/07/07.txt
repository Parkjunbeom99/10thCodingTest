# 07

DP 
->문제를 해결하기 위해 작은 하위 문제로 나누고 , 그 결과를 저장하여 동일한 하위 문제를 반복해서 풀지 않도록 하는 알고리즘 기법

DP의 조건

1. 참조 투명성을 가져야 한다
참조 투명성이란 -> 입력을 제외한 외적요소에 결과값이 영형을 미치지 않고 , 동일한 입력에 대해 동일한 출력을 가져야한다
2. 최적 부분 구조 
문제를 해결할 때 하위 문제들을 해결한 결과를 이용해 전체 문제의 최적 해를 구할 수 있는 경우
    ex-> 피보나치 f(n) = f(n-1) + f(n-2)  -> f(n-1) , f(n-2) 를 구해야 f(n)을 구할 수 있다.
    
3. 겹치는 부분 문제 
동일한 하위 문제가 여러 번의 반복해서 나오는 경우 , 문제의 해를 미리 저장해두고 재사용할 수 있는 구조 

4. DAG(directed acyclic graph) 구조
방향성이 있고 사이클이 없는 그래프 구조를 가져야한다 

사이클이 있는 경우 전처리를 통해 DAG 구조로 변환해야한다.

코테를 할때는 1 ,4번은 신경 쓸 필요가 없고 2,3번만 주요하게 봐라 

     
DP = 완전탐색 + 메모이제이션
DP는 점화식을 먼저 만들고 거기에 맞춰 코드를 구축해야한다
하지만 시간 상의 문제로 완탐으로 모든 경우의 수를 생각하고 그 경우의 수를 메모이제이션을 한다 

== DP 건축
1. 어떠한 idx에서 모든 경우의 수를 생각
2. 그렇게 완전탐색을 하는 구조를 만든다 
3. 그리고 메모이제이션을 건다

메모이제이션 
어떤 상태값을 자료구조에 저장하는 것이다 .
이미 계산한 값을 저장하고 이전에 계산한 값이 있다면 그 값을 사용하는 방식이다.

이렇게 문제를 보고 어떤 상태값을 기반으로 몇개의 차원을 가진 배열을 만들어서 어떻게 메모이제이션을 할건지를 설정하는게 DP의 핵심 중 하나.

DP의 종류
탑다운 방식 - > 피보나치  f(n) = f(n-1) + f(n-2)  -> f(n-1) , f(n-2)
재귀적인 구조를 가지고 있으며 큰 N에서 1 또는 0 등 작은 숫자로 향하게 함수가 호출되며 
DP에 필요한 배열만을 만들며 코드가 직관적이라는 장점과 재귀호출에 대한 오버헤드가 있다는 단점

바텀 업 방식
숫자 0이나 1 부터 시작해 N까지의 반복문을 통해 DP를 만들어낸다 - > 피보나치
 dp[0] = 0; dp[1] = 1; 
 for(int i = 2; i <= n; i++)
 {
  dp[i] = dp[i - 1] + dp[i - 2];
  }
재귀호출에 대한 오버헤드가 없다는 장점이 있지만 문제에 필요한 배열뿐만 아니라 모든 배열을 다 만든다는 단점

보통 탑 다운보다 빠르다 


